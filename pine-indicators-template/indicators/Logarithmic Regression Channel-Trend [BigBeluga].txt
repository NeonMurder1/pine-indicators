// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// © BigBeluga

//@version=6
indicator("Logarithmic Regression Channel-Trend [BigBeluga]", "LogReg Channel-Trend [BigBeluga]", overlay=true)

// ＩＮＰＵＴＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
int   length        = input.int(100, "Lookback Period")
float channel_width = input.float(1.5, "Channel Width", step = 0.1)
int channel_len     = input(100, "Channel Length")
bool  mid_disp      = input.bool(true, "Mid Line", inline = "s")
bool  fill_band     = input.bool(true, "Fill Band", inline = "s")
color col1          = input.color(#21dfac, "", inline = "s1")
color col2          = input.color(#df216d, "", inline = "s1")
// }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Function to compute logarithmic regression
f_log_regression(src, length) =>

    float sumX      = 0.0
    float sumY      = 0.0
    float sumXSqr   = 0.0
    float sumXY     = 0.0

    for i = 0 to length - 1
        val = math.log(src[i])
        per = i + 1.0
        sumX += per
        sumY += val
        sumXSqr += per * per
        sumXY += val * per

    slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)
    average = sumY / length
    intercept = average - slope * sumX / length + slope

    [slope, intercept]

// Calculate slope and intercept
[slope, intercept] = f_log_regression(close, length)

float start     = math.exp(intercept + slope * length)
float end       = math.exp(intercept)
float diff      = end - end[3]
float deviation = ta.stdev(close, length)
bool  up_sig    = ta.crossover(diff, 0) and barstate.isconfirmed
bool  dn_sig    = ta.crossunder(diff, 0) and barstate.isconfirmed
// }



// ＰＬＯＴ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{

// Define Colors
color color_up      = color.from_gradient(diff, ta.lowest(diff,200), ta.highest(diff,200), na, col1)
color color_dn      = color.from_gradient(diff, ta.lowest(diff,200), ta.highest(diff,200), col2, na)
color channel_col   = end > start ? col1 : col2
color trend_col     = end > end[3] ?  color_up : color_dn
color trend_col1    = end > end[3] ?  col1 : col2

p1 = plot(end, "Log Regression", color = trend_col1, linewidth = 2)
p2 = plot(end[3], color = trend_col, display = display.none, editable = false)
plotshape(up_sig ? end : na, "Up", shape.xcross, location.absolute, chart.fg_color, size = size.tiny)
plotshape(dn_sig ? end : na, "Dn", shape.xcross, location.absolute, chart.fg_color, size = size.tiny)

fill(p1, p2, fill_band ? trend_col : na)


// Define upper and lower channel based on standard deviation
var line up1 = na
var line up = na
var line base = na
var line lw = na
var line lw1 = na
var label lbl_t = na


if na(base) and mid_disp
    base := line.new(bar_index[channel_len], start, bar_index, end, style = line.style_dashed)
else 
    base.set_xy1(bar_index[channel_len], start)
    base.set_xy2(bar_index, end)
    base.set_color(chart.fg_color)

if na(up1) 
    up1 := line.new(bar_index[channel_len], start+deviation*(channel_width+0.3), bar_index, end + deviation*(channel_width+0.3), width = 3)
else 
    up1.set_xy1(bar_index[channel_len], start+deviation*(channel_width+0.3))
    up1.set_xy2(bar_index, end + deviation*(channel_width+0.3))
    up1.set_color(channel_col)

if na(up) 
    up := line.new(bar_index[channel_len], start+deviation*channel_width, bar_index, end + deviation*channel_width, width = 1)
else 
    up.set_xy1(bar_index[channel_len], start+deviation*channel_width)
    up.set_xy2(bar_index, end + deviation*channel_width)
    up.set_color(na)

if na(lw) 
    lw := line.new(bar_index[channel_len], start-deviation*channel_width, bar_index, end - deviation*channel_width, width = 1)
else 
    lw.set_xy1(bar_index[channel_len], start-deviation*channel_width)
    lw.set_xy2(bar_index, end - deviation*channel_width)
    lw.set_color(na)

if na(lw1) 
    lw1 := line.new(bar_index[channel_len], start-deviation*(channel_width+0.3), bar_index, end - deviation*(channel_width+0.3), width = 3)
    lbl_t := label.new(bar_index[channel_len], start-deviation*(channel_width+0.3))
else 
    lw1.set_xy1(bar_index[channel_len], start-deviation*(channel_width+0.3))
    lw1.set_xy2(bar_index, end - deviation*(channel_width+0.3))
    lw1.set_color(channel_col)

    lbl_t.set_xy(bar_index[channel_len], start-deviation*(channel_width+0.3))
    lbl_t.set_text(end > start ? "UP" : "DN")
    lbl_t.set_style((end < start ? label.style_label_lower_right : label.style_label_upper_right))
    lbl_t.set_color(channel_col)
    lbl_t.set_textcolor(#070f23)

// Fill Channel Upper and Lower Zones with color
linefill.new(lw, lw1, color.new(channel_col, 70))
linefill.new(up, up1, color.new(channel_col, 70))

// Info Dash
if barstate.islast
    dash = table.new(position.top_right, 10, 10, bgcolor = color.new(chart.fg_color, 90), border_color = chart.bg_color, border_width = 5)
    dash.cell(0, 0, "Slope: " + str.tostring(slope*100, "#,###.###"), text_color = chart.fg_color)
    dash.cell(0, 1, "Log Regression Channel: " + (end > start ? "UP" : "DN"), text_color = channel_col)
    dash.cell(0, 2, "Logarithmic Regression: " + (end > end[3] ? "UP" : "DN"), text_color = color.new(trend_col, 0))
// }