// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © EdgeTerminal

//@version=6

indicator('Adaptive Supply and Demand [EdgeTerminal]', overlay = false)

// Input parameters
shortPeriod = input.int(10, 'Short-term Period', minval = 1)
mediumPeriod = input.int(20, 'Medium-term Period', minval = 1)
longPeriod = input.int(50, 'Long-term Period', minval = 1)
volumeWindow = input.int(20, 'Volume Analysis Window', minval = 1)
confidenceThreshold = input.float(0.7, 'Confidence Threshold', minval = 0.0, maxval = 1.0, step = 0.1)

// Volume Pressure Analysis
volumePressure(src, vol) =>
    float vp = 0.0
    float normVol = vol / ta.sma(vol, volumeWindow)
    float priceChange = src - ta.sma(src, volumeWindow)
    vp := normVol * priceChange
    vp

// Savitzky-Golay filtering approximation using weighted moving average
sgFilter(src, len) =>
    float sg = 0.0
    float weight = 0.0
    for i = 0 to len - 1 by 1
        w = len - math.abs(i - len / 2)
        sg := sg + src[i] * w
        weight := weight + w
        weight
    sg / weight

// Parkinson's Volatility
parkinsonsVolatility(len) =>
    float pv = 0.0
    float sum = 0.0
    for i = 0 to len - 1 by 1
        hlr = math.log(high[i] / low[i])
        sum := sum + math.pow(hlr, 2)
        sum
    pv := math.sqrt(sum / (4 * len * math.log(2))) * math.sqrt(252)
    pv

// Multi-timeframe Momentum
momentum(src, shortLen, medLen, longLen) =>
    float shortMom = ta.roc(src, shortLen)
    float medMom = ta.roc(src, medLen)
    float longMom = ta.roc(src, longLen)
    float compositeMom = shortMom * 0.5 + medMom * 0.3 + longMom * 0.2
    compositeMom

// Dynamic Support/Resistance
dynamicLevels(src, len) =>
    var float support = na
    var float resistance = na
    float priceRange = ta.highest(high, len) - ta.lowest(low, len)
    float volWeight = volume / ta.sma(volume, len)

    if ta.crossover(src, ta.highest(high, len)[1])
        resistance := src * (1 + volWeight * 0.1)
        resistance
    if ta.crossunder(src, ta.lowest(low, len)[1])
        support := src * (1 - volWeight * 0.1)
        support

    [support, resistance]

// Confidence Scoring
confidenceScore(vp, mom, vol, pa) =>
    float score = 0.0
    score := vp * 0.3 + mom * 0.25 + (1 - vol) * 0.2 + pa * 0.25
    score

// Calculate main indicators
float price = close
float vp = volumePressure(price, volume)
float filteredPrice = sgFilter(price, 5)
float vol = parkinsonsVolatility(14)
float mom = momentum(price, shortPeriod, mediumPeriod, longPeriod)
[sup, res] = dynamicLevels(price, 20)

// Calculate demand and supply lines with enhanced logic
float demand = ta.ema(filteredPrice * (1 + mom) * (1 + vp / 1000), shortPeriod)
float supply = ta.ema(filteredPrice * (1 - mom) * (1 - vp / 1000), mediumPeriod)

// Calculate confidence score
float priceAction = math.abs(price - filteredPrice) / price
float confidence = confidenceScore(vp / 1000, mom, vol, priceAction)

// Generate signals
bool upSignal = ta.crossover(demand, supply) and confidence >= confidenceThreshold
bool downSignal = ta.crossunder(demand, supply) and confidence >= confidenceThreshold

// Plotting
plot(demand, 'Demand Line', color = color.green, linewidth = 2)
plot(supply, 'Supply Line', color = color.red, linewidth = 2)


// Plot support/resistance levels when they're detected
plot(sup, 'Dynamic Support', color = color.rgb(221, 221, 221), style = plot.style_circles, linewidth = 1)
plot(res, 'Dynamic Resistance', color = color.rgb(255, 179, 79), style = plot.style_circles, linewidth = 1)

// Alert conditions
alertcondition(upSignal, title = 'Buy Signal', message = 'Demand crossed above Supply with high confidence')
alertcondition(downSignal, title = 'Sell Signal', message = 'Demand crossed below Supply with high confidence')

// Helper function for color transparency
getColorTransparency(value) =>
    int transparency = math.abs(value) > 1 ? 40 : math.round(90 - math.abs(value) * 50)
    math.max(transparency, 20)

// Add table with key metrics
var table metricsTable = table.new(position.top_right, 2, 5)
if barstate.islast
    // Calculate color intensities based on values
    color confColor = confidence >= 0.7 ? color.green : confidence >= 0.5 ? color.yellow : color.red
    color momColor = mom > 0 ? color.green : color.red
    color vpColor = vp > 0 ? color.green : color.red
    color volColor = vol > 0.2 ? color.red : vol > 0.1 ? color.yellow : color.green

    // Update table cells with dynamic colors
    table.cell(metricsTable, 0, 0, 'Confidence', bgcolor = color.new(#ffffff, 0))
    table.cell(metricsTable, 1, 0, str.tostring(math.round(confidence * 100, 1)) + '%', bgcolor = color.new(confColor, getColorTransparency(confidence)), text_color = color.white)

    table.cell(metricsTable, 0, 1, 'Momentum', bgcolor = color.new(#ffffff, 0))
    table.cell(metricsTable, 1, 1, str.tostring(math.round(mom * 100, 2)) + '%', bgcolor = color.new(momColor, getColorTransparency(math.abs(mom))), text_color = color.white)

    table.cell(metricsTable, 0, 2, 'Vol Pressure', bgcolor = color.new(#ffffff, 0))
    table.cell(metricsTable, 1, 2, str.tostring(math.round(vp, 2)), bgcolor = color.new(vpColor, getColorTransparency(math.abs(vp / 1000))), text_color = color.white)

    table.cell(metricsTable, 0, 3, 'Volatility', bgcolor = color.new(#ffffff, 0))
    table.cell(metricsTable, 1, 3, str.tostring(math.round(vol * 100, 2)) + '%', bgcolor = color.new(volColor, getColorTransparency(vol)), text_color = color.white)
