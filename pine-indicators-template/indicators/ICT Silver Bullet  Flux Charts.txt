// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © fluxchart

//@version=5

const bool DEBUG = false
const int showLastXLiqs = 10
const int maxDistanceToLastBar = 50000 // Affects Running Time
const int atrLen = 5
const bool maxTPLastHour = false
const int extendFVG = 15

var initRun = true

indicator("ICT Silver Bullet | Flux Charts", shorttitle = "Silver Bullet | Flux Charts", overlay = true, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500)

nySession1 = "1000-1100"
nySession2 = "1400-1500"
londonSession = "0300-0400"

//pivotLenLiq = input.int(4, "Pivot Length", group = "General Configuration", display = display.none)
executionType = input.string("FVG", "Execution Type", options = ["FVG", "MSS"], group = "General Configuration", tooltip = "FVG -> recommended for 1-min timeframe.\n\nMSS -> recommended for 5-min timeframe.")
mssOffset = input.int(10, "MSS Swing Length", group = "General Configuration")
breakoutMethod = input.string("Wick", "Breakout Method", options = ["Close", "Wick"], group = "General Configuration")
fvgBars = input.string("Same Type", "FVG Detection", options = ["Same Type", "All"], tooltip = "Same Type -> All 3 bars that formed the FVG should be the same type. (Bullish / Bearish) \n\nAll -> Bar types may vary between bullish / bearish.", group = "General Configuration")
fvgSensEnabled = input.bool(true, "", "", "sens", "General Configuration")
fvgSensitivityText = input.string("Extreme", "FVG Detection Sensitivity", options = ["Extreme", "High", "Normal", "Low"], inline = "sens", group = "General Configuration")
fvgEntry = DEBUG ? input.string("Along", "FVG Entry", options = ["All", "Along", "Inverse"], group = "General Configuration") : "Along"
allowGaps = true
fvgSensitivity = fvgSensitivityText == "Extreme" ? 6 : fvgSensitivityText == "High" ? 2 : fvgSensitivityText == "Normal" ? 1.5 : 1
showSessions = input.bool(true, "Show Sessions", inline = "2", group = "General Configuration")
showHL = input.bool(false, "Highs / Lows", inline = "2", group = "General Configuration")
showFVGs = input.bool(true, "FVGs", inline = "2", group = "General Configuration")
showTPSL = input.bool(true, "TP / SL", inline = "2", group = "General Configuration")

tpslMethod = input.string("Dynamic", "TP / SL Method", options = ["Dynamic", "Fixed"], group = "TP / SL")
riskAmount = input.string("Normal", "Risk", options = ["High", "Normal", "Low"], group = "TP / SL", tooltip = "The risk amount when Dynamic TP / SL method is selected.")
tpPercent = input.float(0.3, "Take Profit %", group = "TP / SL")
slPercent = input.float(0.4, "Stop Loss %", group = "TP / SL")
closePositionAtEndSession = input.bool(true, "Close Position @ Session End", group = "TP / SL")

RR = DEBUG ? input.float(0.99, "Risk:Reward Ratio", group = "Debug") : 0.99
//requireFVGRetracement = DEBUG ? input.bool(true, "Require FVG Retracement", group = "Debug") : true
requireFVGRetracement = DEBUG ? input.bool(true, "[DBG] Require FVG Retracement", group = "Debug") : true

//slATRMult = DEBUG ? input.float(6, "SL ATR Mult", group = "Debug") : 6
slATRMult = riskAmount == "High" ? 6.5 : riskAmount == "Normal" ? 5.5 : 3.5

executeInsideSession = DEBUG ? input.bool(true, "Must Execute Inside Session", group = "Debug", display = display.none) : true
ny1Enabled = DEBUG ? input.bool(true, "NY 1", group = "Debug", display = display.none) : true
ny2Enabled = DEBUG ? input.bool(true, "NY 2", group = "Debug", display = display.none) : true
lnEnabled = DEBUG ? input.bool(true, "London", group = "Debug", display = display.none) : true

backtestDisplayEnabled = input.bool(true, "Enabled", group = "Backtesting Dashboard", display = display.none)
backtestingLocation = input.string("Top Center", "Position", options = ["Top Right", "Right Center", "Top Center"], group = "Backtesting Dashboard", display = display.none)
fillBackgrounds = input.bool(true, "Fill Backgrounds", group = "Backtesting Dashboard", display = display.none)
screenerColor = input.color(#1B1F2B, 'Background', inline = "1", group = 'Backtesting Dashboard', display = display.none)

highColor = input.color(color.green, "Buy", inline = "colors", group = "Visuals")
lowColor = input.color(color.red, "Sell", inline = "colors", group = "Visuals")
textColor = input.color(color.white, "Text", inline = "colors", group = "Visuals")

buyAlertEnabled = input.bool(true, "Buy Signal", inline = "BS", group = "Alerts")
sellAlertEnabled = input.bool(true, "Sell Signal", inline = "BS", group = "Alerts")
tpAlertEnabled = input.bool(true, "Take-Profit Signal", inline = "TS", group = "Alerts")
slAlertEnabled = input.bool(true, "Stop-Loss Signal ", inline = "TS", group = "Alerts")

buyAlertTick = false
sellAlertTick = false
tpAlertTick = false
slAlertTick = false

type FVG
    int startTime
    int endTime
    float top
    float bottom
    bool isBull

type Sweep
    int startTime
    int endTime
    string side
    float price

type SilverBullet
    string state
    int startTime

    int lastHour = na
    float lastHourHigh = na
    float lastHourLow = na
    Sweep brokenSweep = na
    float slTarget
    float tpTarget
    string entryType
    int entryTime
    int exitTime
    float entryPrice
    float exitPrice
    int dayEndedBeforeExit
    FVG fvg


var lineX = array.new<line>()
var boxX = array.new<box>()
var labelX = array.new<label>()

var SilverBullet[] sbList = array.new<SilverBullet>(0)
var SilverBullet lastSB = na

atr = ta.atr(atrLen)

diffPercent (float val1, float val2) =>
    (math.abs(val1 - val2) / val2) * 100.0

getPosition (positionText) =>
    if positionText == "Top Right"
        position.top_right
    else if positionText == "Top Center"
        position.top_center
    else if positionText == "Right Center"
        position.middle_right
    else if positionText == "Left Center"
        position.middle_left
    else if positionText == "Bottom Center"
        position.bottom_center
    else if positionText == "Middle Center"
        position.middle_center

tfInMin = timeframe.in_seconds() / 60
if tfInMin > 5
    runtime.error("Silver Bullet indicator only works timeframes <= 5 Minutes.")

//#region Liqs
int barLength = 60 / tfInMin
float high12 = ta.highest(barLength)
float low12 = ta.lowest(barLength)
float highMSS = ta.highest(mssOffset)
float lowMSS = ta.lowest(mssOffset)
int lastHourTime = time[barLength]
//#endregion

sessionBegins(sess) =>
    t = time("1440", sess, "America/New_York")
    is_first = na(t[1]) and not na(t) or t[1] < t

newSession = (ny1Enabled and sessionBegins(nySession1)) or (ny2Enabled and sessionBegins(nySession2)) or (lnEnabled and sessionBegins(londonSession))
insideSession = (ny1Enabled and not na(time("", nySession1, "America/New_York"))) or (ny2Enabled and not na (time("", nySession2, "America/New_York"))) or (lnEnabled and not na(time("", londonSession, "America/New_York")))
endSession = (not insideSession and insideSession[1])

//#region Silver Bullet
if bar_index > last_bar_index - maxDistanceToLastBar
    // FVG End
    if not na(lastSB) and endSession
        if not na(lastSB.fvg)
            if na(lastSB.fvg.endTime)
                lastSB.fvg.endTime := time
    
    if not na(lastSB)
        if not na(lastSB.fvg)
            if na(lastSB.fvg.endTime) and ((lastSB.fvg.isBull and low <= lastSB.fvg.bottom) or (not lastSB.fvg.isBull and high >= lastSB.fvg.top))
                lastSB.fvg.endTime := time
    if true
        // Find Session Start
        if newSession
            createNewSB = true
            if not na(lastSB)
                if not na(lastSB.entryPrice) and na(lastSB.exitPrice)
                    if closePositionAtEndSession
                        lastSB.dayEndedBeforeExit := time[1]
                        lastSB.exitTime := time
                        lastSB.exitPrice := close
                    else
                        createNewSB := false // Don't enter if a trade is already entered
                    
            if createNewSB
                newSB = SilverBullet.new("Waiting For Liquidity Break", time)
                newSB.lastHourHigh := high12
                newSB.lastHourLow := low12
                newSB.lastHour := lastHourTime
                sbList.unshift(newSB)
                lastSB := newSB

        if not na(lastSB)
            // FVG
            fvgEnter = false
            if na(lastSB.fvg) and lastSB.state != "Waiting For Liquidity Break" and ((not executeInsideSession) or insideSession)
                bearCondition = false
                bullCondition = false

                firstBarSize = math.max(open, close) - math.min(open, close)
                secondBarSize = math.max(open[1], close[1]) - math.min(open[1], close[1])
                thirdBarSize = math.max(open[2], close[2]) - math.min(open[2], close[2])
                barSizeSum = firstBarSize + secondBarSize + thirdBarSize

                barSizeCheck = true
                //if (secondBarSize * fvgSensitivity < (firstBarSize + thirdBarSize) * 1.5)
                    //barSizeCheck := false

                fvgBarsCheck = false
                if fvgBars == "Same Type"
                    if (open > close and open[1] > close[1] and open[2] > close[2]) or (open <= close and open[1] <= close[1] and open[2] <= close[2])
                        fvgBarsCheck := true
                else
                    fvgBarsCheck := true

                if fvgBarsCheck and barSizeCheck
                    maxCODiff = math.max(math.abs(close[2] - open[1]), math.abs(close[1] - open))
                    bearCondition := ((not fvgSensEnabled) or (barSizeSum * fvgSensitivity > atr / 1.5)) and (allowGaps or (maxCODiff <= atr))
                    bullCondition := ((not fvgSensEnabled) or (barSizeSum * fvgSensitivity > atr / 1.5)) and (allowGaps or (maxCODiff <= atr))

                bearFVG = high < low[2] and close[1] < low[2] and bearCondition
                bullFVG = low > high[2] and close[1] > high[2] and bullCondition

                FVGSize = bearFVG ? math.abs(low[2] - high) : bullFVG ? math.abs(low - high[2]) : 0
                FVGSizeEnough = (FVGSize * fvgSensitivity > atr)
            
                if (bearFVG or bullFVG) and (FVGSizeEnough or (not fvgSensEnabled))
                    if (fvgEntry == "All")
                        fvgEnter := true
                    
                    if (fvgEntry == "Along")
                        if (lastSB.entryType == "Long" and bullFVG) or (lastSB.entryType == "Short" and bearFVG)
                            fvgEnter := true
                    
                    if (fvgEntry == "Inverse")
                        if (lastSB.entryType == "Long" and bearFVG) or (lastSB.entryType == "Short" and bullFVG)
                            fvgEnter := true
                    lastSB.fvg := FVG.new(time, na, bearFVG ? low[2] : low, bearFVG ? high : high[2], bullFVG)

            // Find Liquidity Breaks
            if lastSB.state == "Waiting For Liquidity Break"
                if time > lastSB.startTime
                    if (breakoutMethod == "Close" ? close : low) < lastSB.lastHourLow
                        lastSB.brokenSweep := Sweep.new(lastSB.lastHour, time, "Sellside", lastSB.lastHourLow)
                        lastSB.entryType := "Long"
                        lastSB.state := "Waiting For Execution"
                    
                    else if (breakoutMethod == "Close" ? close : high) > lastSB.lastHourHigh
                        lastSB.brokenSweep := Sweep.new(lastSB.lastHour, time, "Buyside", lastSB.lastHourHigh)
                        lastSB.entryType := "Short"
                        lastSB.state := "Waiting For Execution"
            // Execute
            if lastSB.state == "Waiting For Execution" and ((not executeInsideSession) or insideSession)
                if time > lastSB.brokenSweep.endTime
                    if executionType == "MSS"
                        if lastSB.brokenSweep.side == "Buyside" // Short
                            if (breakoutMethod == "Close" ? close : low) < lowMSS[1]
                                sellAlertTick := true
                                lastSB.state := "Entry Taken"
                                lastSB.entryTime := time
                                lastSB.entryPrice := (breakoutMethod == "Close" ? close : lowMSS[1])
                                if tpslMethod == "Fixed"
                                    lastSB.slTarget := lastSB.entryPrice * (1 + slPercent / 100.0)
                                    lastSB.tpTarget := lastSB.entryPrice * (1 - tpPercent / 100.0)
                                else
                                    lastSB.slTarget := highMSS + atr * slATRMult
                                    lastSB.tpTarget := lastSB.entryPrice - (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
                        else // Long
                            if (breakoutMethod == "Close" ? close : high) > highMSS[1]
                                buyAlertTick := true
                                lastSB.state := "Entry Taken"
                                lastSB.entryTime := time
                                lastSB.entryPrice := (breakoutMethod == "Close" ? close : highMSS[1])
                                if tpslMethod == "Fixed"
                                    lastSB.slTarget := lastSB.entryPrice * (1 - slPercent / 100.0)
                                    lastSB.tpTarget := lastSB.entryPrice * (1 + tpPercent / 100.0)
                                else
                                    lastSB.slTarget := lowMSS - atr * slATRMult
                                    lastSB.tpTarget := lastSB.entryPrice + (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
                    else if fvgEnter and executionType == "FVG"
                        if not requireFVGRetracement
                            lastSB.state := "Entry Taken"
                            lastSB.entryTime := time
                            lastSB.entryPrice := close
                            if lastSB.entryType == "Long"
                                buyAlertTick := true
                                if tpslMethod == "Fixed"
                                    lastSB.slTarget := lastSB.entryPrice * (1 - slPercent / 100.0)
                                    lastSB.tpTarget := lastSB.entryPrice * (1 + tpPercent / 100.0)
                                else
                                    lastSB.slTarget := lowMSS - atr * slATRMult
                                    lastSB.tpTarget := lastSB.entryPrice + (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
                            else
                                sellAlertTick := true
                                if tpslMethod == "Fixed"
                                    lastSB.slTarget := lastSB.entryPrice * (1 + slPercent / 100.0)
                                    lastSB.tpTarget := lastSB.entryPrice * (1 - tpPercent / 100.0)
                                else
                                    lastSB.slTarget := highMSS + atr * slATRMult
                                    lastSB.tpTarget := lastSB.entryPrice - (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
                        else
                            lastSB.state := "FVG Retracement"

    // FVG Retracement
    if not na(lastSB)
        if lastSB.state == "FVG Retracement" and ((not executeInsideSession) or insideSession)
            if (lastSB.fvg.isBull and (breakoutMethod == "Close" ? close : low) < lastSB.fvg.top) or (not lastSB.fvg.isBull and (breakoutMethod == "Close" ? close : high) > lastSB.fvg.bottom)
                lastSB.state := "Entry Taken"
                lastSB.entryTime := time
                lastSB.entryPrice := close
                if lastSB.entryType == "Long"
                    buyAlertTick := true
                    if tpslMethod == "Fixed"
                        lastSB.slTarget := lastSB.entryPrice * (1 - slPercent / 100.0)
                        lastSB.tpTarget := lastSB.entryPrice * (1 + tpPercent / 100.0)
                    else
                        lastSB.slTarget := lowMSS - atr * slATRMult
                        lastSB.tpTarget := lastSB.entryPrice + (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
                else
                    sellAlertTick := true
                    if tpslMethod == "Fixed"
                        lastSB.slTarget := lastSB.entryPrice * (1 + slPercent / 100.0)
                        lastSB.tpTarget := lastSB.entryPrice * (1 - tpPercent / 100.0)
                    else
                        lastSB.slTarget := highMSS + atr * slATRMult
                        lastSB.tpTarget := lastSB.entryPrice - (math.abs(lastSB.entryPrice - lastSB.slTarget) * RR)
    
    // Entry Taken
    if not na(lastSB)
        if lastSB.state == "Entry Taken"
            if tpslMethod == "Fixed"
                // Take Profit
                if lastSB.entryType == "Long" and ((high / lastSB.entryPrice) - 1) * 100 >= tpPercent
                    tpAlertTick := true
                    lastSB.exitPrice := lastSB.entryPrice * (1 + tpPercent / 100.0)
                    lastSB.exitTime := time
                    lastSB.state := "Take Profit"
                if lastSB.entryType == "Short" and ((low / lastSB.entryPrice) - 1) * 100 <= -tpPercent
                    tpAlertTick := true
                    lastSB.exitPrice := lastSB.entryPrice * (1 - tpPercent / 100.0)
                    lastSB.exitTime := time
                    lastSB.state := "Take Profit"
                
                // Stop Loss
                if lastSB.entryType == "Long" and ((low / lastSB.entryPrice) - 1) * 100 <= -slPercent
                    slAlertTick := true
                    lastSB.exitPrice := lastSB.entryPrice * (1 - slPercent / 100.0)
                    lastSB.exitTime := time
                    lastSB.state := "Stop Loss"
                if lastSB.entryType == "Short" and ((high / lastSB.entryPrice) - 1) * 100 >= slPercent
                    slAlertTick := true
                    lastSB.exitPrice := lastSB.entryPrice * (1 + slPercent / 100.0)
                    lastSB.exitTime := time
                    lastSB.state := "Stop Loss"
            else
                // Take Profit
                if lastSB.entryType == "Long" and ((maxTPLastHour and high >= lastSB.lastHourHigh) or high >= lastSB.tpTarget)
                    tpAlertTick := true
                    lastSB.exitPrice := (high >= math.max(lastSB.lastHourHigh, lastSB.tpTarget) ? math.max(lastSB.lastHourHigh, lastSB.tpTarget) : math.min(lastSB.lastHourHigh, lastSB.tpTarget))
                    lastSB.exitTime := time
                    lastSB.state := "Take Profit"
                if lastSB.entryType == "Short" and ((maxTPLastHour and low <= lastSB.lastHourLow) or low <= lastSB.tpTarget)
                    tpAlertTick := true
                    lastSB.exitPrice := (low <= math.min(lastSB.lastHourLow, lastSB.tpTarget) ? math.min(lastSB.lastHourLow, lastSB.tpTarget) : math.max(lastSB.lastHourLow, lastSB.tpTarget))
                    lastSB.exitTime := time
                    lastSB.state := "Take Profit"
                
                // Stop Loss
                if lastSB.entryType == "Long" and low <= lastSB.slTarget
                    slAlertTick := true
                    lastSB.exitPrice := lastSB.slTarget
                    lastSB.exitTime := time
                    lastSB.state := "Stop Loss"
                if lastSB.entryType == "Short" and high >= lastSB.slTarget
                    slAlertTick := true
                    lastSB.exitPrice := lastSB.slTarget
                    lastSB.exitTime := time
                    lastSB.state := "Stop Loss"
//#endregion

//#region Plotting
tfs = (30 / (timeframe.in_seconds(timeframe.period) / 60))

plotColor = color.new(textColor, 60)
plotchar(not na(time("", nySession1, "America/New_York")) and newSession and showSessions, title = 'NY Session 1', location = location.top, text='10-11 AM\nNY', color=color.new(color.black, 100), textcolor=plotColor, offset= +tfs)
plotchar(not na(time("", nySession2, "America/New_York")) and newSession and showSessions, title = 'NY Session 2', location = location.top, text='2-3 PM\nNY', color=color.new(color.black, 100), textcolor=plotColor, offset= +tfs)
plotchar(not na(time("", londonSession, "America/New_York")) and newSession and showSessions, title = 'London Session', location = location.top, text='3-4 AM\nNY', color=color.new(color.black, 100), textcolor=plotColor, offset= +tfs)

if (newSession or endSession) and showSessions
    line.new(bar_index, close, bar_index, close + syminfo.mintick, color = plotColor, extend=extend.both)

//#endregion

//#region Render Silver Bullets

renderTopSL = false
renderBottomSL = false
renderTopTP = false
renderBottomTP = false

if not na(lastSB)
    if lastSB.state == "Stop Loss" and time > lastSB.exitTime
        if lastSB.entryType == "Long"
            renderBottomSL := true
        else
            renderTopSL := true
        lastSB.state := "Done"
    if lastSB.state == "Take Profit"
        if lastSB.entryType == "Long"
            renderTopTP := true
        else
            renderBottomTP := true
        lastSB.state := "Done"

plotshape(renderTopSL, "", shape.circle, location.abovebar, color.red, textcolor = textColor, text = "SL", size = size.tiny)
plotshape(renderBottomSL, "", shape.circle, location.belowbar, color.red, textcolor = textColor, text = "SL", size = size.tiny)
plotshape(renderTopTP, "", shape.xcross, location.abovebar, color.blue, textcolor = textColor, text = "TP", size = size.tiny)
plotshape(renderBottomTP, "", shape.xcross, location.belowbar, color.blue, textcolor = textColor, text = "TP", size = size.tiny)

//#endregion

//#region Alerts
if barstate.islastconfirmedhistory
    initRun := false

alertcondition(buyAlertTick and not initRun, "Buy Signal", "")
alertcondition(sellAlertTick and not initRun, "Sell Signal", "")
alertcondition(tpAlertTick and not initRun, "Take-Profit Signal", "")
alertcondition(slAlertTick and not initRun, "Stop-Loss Signal", "")

if not initRun
    if buyAlertTick and buyAlertEnabled
        alert("Buy Signal")
    if sellAlertTick and sellAlertEnabled
        alert("Sell Signal")
    
    if tpAlertTick and tpAlertEnabled
        alert("Take-Profit Signal")
    if slAlertTick and slAlertEnabled
        alert("Stop-Loss Signal")

//#endregion

if barstate.isconfirmed
    if lineX.size() > 0
        for i = 0 to lineX.size() - 1
            line.delete(lineX.get(i))

    if boxX.size() > 0
        for i = 0 to boxX.size() - 1
            box.delete(boxX.get(i))
    
    if labelX.size() > 0
        for i = 0 to labelX.size() - 1
            label.delete(labelX.get(i))

    lineX.clear()
    boxX.clear()
    labelX.clear()
    
    if sbList.size() > 0
        for i = 0 to sbList.size() - 1
            curSB = sbList.get(i)

            // Last Hour
            if not na(curSB.brokenSweep) and showHL
                lineX.push(line.new(curSB.brokenSweep.startTime, curSB.lastHourHigh, curSB.brokenSweep.endTime, curSB.lastHourHigh, xloc = xloc.bar_time, color = lowColor, style = (curSB.brokenSweep.price == curSB.lastHourHigh ? line.style_dashed : line.style_solid)))
                lineX.push(line.new(curSB.brokenSweep.startTime, curSB.lastHourLow, curSB.brokenSweep.endTime, curSB.lastHourLow, xloc = xloc.bar_time, color =highColor, style = (curSB.brokenSweep.price == curSB.lastHourLow ? line.style_dashed : line.style_solid)))

            if not na(curSB.entryTime)
                // Entry Label
                if curSB.entryType == "Long"
                    labelX.push(label.new(curSB.entryTime, close, "Buy", xloc = xloc.bar_time, yloc = yloc.belowbar, textcolor = textColor, color = highColor, style = label.style_label_up, size = size.small))
                else
                    labelX.push(label.new(curSB.entryTime, close, "Sell", xloc = xloc.bar_time, yloc = yloc.abovebar, textcolor = textColor, color = lowColor, style = label.style_label_down, size = size.small))
            
                // FVG
                if showFVGs
                    if not na(curSB.fvg)
                        boxX.push(box.new(curSB.fvg.startTime, curSB.fvg.top, nz(curSB.fvg.endTime, time("", -extendFVG)), curSB.fvg.bottom, border_width = 0, xloc = xloc.bar_time, bgcolor = (curSB.fvg.isBull ? highColor : lowColor)))

            // TP / SL
            if not na(curSB.entryTime)
                if showTPSL
                    offset = atr / 3.0
                    boxX.push(box.new(curSB.entryTime, curSB.tpTarget + offset, nz(curSB.exitTime, time("", -extendFVG)), curSB.tpTarget - offset, text = "TAKE PROFIT (" + str.tostring(curSB.tpTarget, format.mintick) + ")", text_color = textColor, xloc = xloc.bar_time, border_width = 0, bgcolor = color.new(highColor, 50), text_size = size.small))
                    boxX.push(box.new(curSB.entryTime, curSB.slTarget + offset, nz(curSB.exitTime, time("", -extendFVG)), curSB.slTarget - offset, text = "STOP LOSS (" + str.tostring(curSB.slTarget, format.mintick) + ")", text_color = textColor, xloc = xloc.bar_time, border_width = 0, bgcolor = color.new(lowColor, 50) , text_size = size.small))

            if not na(curSB.dayEndedBeforeExit)
                labelX.push(label.new(curSB.dayEndedBeforeExit, close, "Exit", xloc = xloc.bar_time, yloc = yloc.belowbar, textcolor = textColor, color = color.yellow, style = label.style_circle, size = size.tiny))

//#region Backtesting Dashboard

if barstate.islast and backtestDisplayEnabled
    var table backtestDisplay = table.new(getPosition(backtestingLocation), 2, 10, bgcolor = screenerColor, frame_width = 2, frame_color = color.black, border_width = 1, border_color = color.black)
    
    float totalSBProfitPercent = 0
    int successfulTrades = 0
    int unsuccessfulTrades = 0

    if sbList.size() > 0
        for i = 0 to sbList.size() - 1
            curSB = sbList.get(i)
            if not na(curSB.entryPrice)
                isSuccess = false
                if not na(curSB.exitPrice)
                    if (curSB.entryType == "Long" and curSB.exitPrice > curSB.entryPrice) or (curSB.entryType == "Short" and curSB.exitPrice < curSB.entryPrice)
                        totalSBProfitPercent += math.abs(diffPercent(curSB.entryPrice, curSB.exitPrice))
                        isSuccess := true
                    else
                        totalSBProfitPercent -= math.abs(diffPercent(curSB.entryPrice, curSB.exitPrice))
                        isSuccess := false

                if isSuccess
                    successfulTrades += 1
                else
                    unsuccessfulTrades += 1
    
    // Header
    table.merge_cells(backtestDisplay, 0, 0, 1, 0)
    table.cell(backtestDisplay, 0, 0, "SB Backtesting", text_color = color.white, bgcolor = screenerColor)

    // Total ORBs
    table.cell(backtestDisplay, 0, 1, "Total Entries", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 1, str.tostring(successfulTrades + unsuccessfulTrades), text_color = color.white, bgcolor = screenerColor)

    // Wins
    table.cell(backtestDisplay, 0, 2, "Wins", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 2, str.tostring(successfulTrades), text_color = color.white, bgcolor = screenerColor)

    // Losses
    table.cell(backtestDisplay, 0, 3, "Losses", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 3, str.tostring(unsuccessfulTrades), text_color = color.white, bgcolor = screenerColor)

    // Winrate
    table.cell(backtestDisplay, 0, 4, "Winrate", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 4, str.tostring(100.0 * (successfulTrades / (successfulTrades + unsuccessfulTrades)), "#.##") + "%", text_color = color.white, bgcolor = screenerColor)

    // Average Profit %
    table.cell(backtestDisplay, 0, 5, "Average Profit", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 5, str.tostring(totalSBProfitPercent / (successfulTrades + unsuccessfulTrades), "#.##") + "%", text_color = color.white, bgcolor = screenerColor)

    // Total Profit %
    table.cell(backtestDisplay, 0, 6, "Total Profit", text_color = color.white, bgcolor = screenerColor)
    table.cell(backtestDisplay, 1, 6, str.tostring(totalSBProfitPercent, "#.##") + "%", text_color = color.white, bgcolor = screenerColor)

//#endregion