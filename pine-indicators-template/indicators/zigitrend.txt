//@version=4
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© RafaelZioni
//@version=4
study("ZigiTrend", overlay=true)
src = close
length = input(20)
mult = 2
dev = mult * stdev(src, length)
upper = highest(high, length)[1]
lower = lowest(low, length)[1]
basis = (upper + lower) / 2

//

tPeriods =input(30)

donchian(len) =>
    avg(lowest(len), highest(len))
tper = donchian(tPeriods)



//INPUTS
tf = input(1440)
per = timeframe.isintraday and timeframe.multiplier >= 1 ? 
   tf / timeframe.multiplier * 7 : 
   timeframe.isintraday and timeframe.multiplier < 60 ? 
   60 / timeframe.multiplier * 24 * 7 : 7


//CHANNEL
hb = highest(high, per)  //High Border
lb = lowest(low, per)  //Low Border
dist = hb - lb  //range of the channel 
med = (hb + lb) / 2  //median of the channel

hf = hb - dist * 0.236  //Highest Fib
chf = hb - dist * 0.382  //Center High Fib
clf = hb - dist * 0.618  //Center Low Fib
lf = hb - dist * 0.764  //Lowest Fib
//
meanp = plot(med, title="Mean ", color=color.gray)  
bsign = plot(hb, title="Upper ", color=color.green, linewidth=2)  
ssign = plot(lb, title="Lower", color=color.red, linewidth=2)  
hf1 = plot(hf, title="Upper fib ", color=color.yellow, linewidth=2)  
chf1 = plot(chf, title="center high fib", color=color.orange, linewidth=2) 
clf1 = plot(clf, title="center low fib ", color=color.lime, linewidth=2)  
lf1 = plot(lf, title="low fib", color=color.blue, linewidth=2) 

fill(bsign, hf1, title="Upper ", color=color.gray)  
fill(ssign, lf1, title="Lower", color=color.yellow) 
//
// Rounding levels to min tick
nround(x) => 
    n = round(x / syminfo.mintick) * syminfo.mintick
//
disp_panels = input(true, title="Display info panels?")
fibs_label_off = input(5, title="fibs label offset")
fibs_label_size = input(size.normal, options=[size.tiny, size.small, size.normal, size.large, size.huge], title="fibs label size")
r1_x = timenow + round(change(time)*fibs_label_off)
r1_y = hb
text1 = "High : " + tostring(nround(hb))
s1_y = lb
text3 = "low : " + tostring(nround(lb))

R1_label = disp_panels ? label.new(x=r1_x, y=r1_y, text=text1, xloc=xloc.bar_time, yloc=yloc.price, color=color.orange, style=label.style_labeldown, textcolor=color.black, size=fibs_label_size) : na
S1_label = disp_panels ? label.new(x=r1_x, y=s1_y, text=text3, xloc=xloc.bar_time, yloc=yloc.price, color=color.lime, style=label.style_labelup, textcolor=color.black, size=fibs_label_size) : na

label.delete(R1_label[1])
label.delete(S1_label[1])
//
lineColor = close > tper[1] ? color.green : color.red
p1 = plot(basis, color=color.red, title="basis", transp=0)
p2 = plot(tper, color=color.green, title="tper", transp=0)
fill(p1, p2, color=lineColor)
//
//
f_draw_infopanel(_x, _y, _line, _text, _color)=>
    _rep_text = ""
    for _l = 0 to _line
        _rep_text := _rep_text + "\n"
    _rep_text := _rep_text + _text
    var label _la = na
    label.delete(_la)
    _la := label.new(
         x=_x, y=_y, 
         text=_rep_text, xloc=xloc.bar_time, yloc=yloc.price, 
         color=color.yellow, style=label.style_labelup, textcolor=_color, size=size.large)

posx = timenow + round(change(time)*10)
posy = highest(30)


f_draw_infopanel(posx, posy, 0, "Trend", close[1] > basis ? color.lime : color.red)
//
//
st_mult   = input(0.1,   title = 'Trend Multiplier', minval = 0, maxval = 100, step = 0.01)
st_period = input(10, title = 'Trend Period',     minval = 1)

// CALCULATIONS //
up_lev =close - (st_mult * atr(st_period))
dn_lev = close + (st_mult * atr(st_period))
//
percent1 = input(title="Percent, 1 = 1%", defval=2, minval=0.001, maxval=20, step=0.001, type=input.float)
percent = percent1 * 0.01


hh = 0.00  //Highest High
hh := nz(hh[1])
hhh = 0.000
hhh := nz(hhh[1])

ll = 0.00  //Lowest Low
ll := nz(ll[1])
lll = 0.000
lll := nz(lll[1])

count = 0
count := nz(count[1]) + 1

trend = 0
trend := nz(trend[1])
nimo = dn_lev
ximo =up_lev


if barstate.isfirst
    count := 0
    ll := nimo  //Lowest low 
    hh := ximo  //Highest high                        
    lll := low  //Lowest low low
    hhh := high  //Highest high high 
    hhh
if count == 1
    if ximo >= hh[1]
        hh := ximo
        hhh := high
        trend := 1  //up
        trend
    else
        ll := nimo
        lll := low
        trend := -1  //down
        trend

if count > 1

    if trend[1] > 0  //if trend up
        hhh := max(hhh[1], high)
        if ximo >= hh[1]  //if High greater or equal to Highest high
            hh := ximo
            hh
        else

            //else (High is smaller than Highest high)
            if nimo < hh[1] - hh[1] * percent  //if low < Highest high - Highest high * Percent
                ll := nimo  //Lowest low = low
                lll := low

                trend := -1  //trend down
                trend
    else

        //else (trend down)
        lll := min(lll[1], low)

        if nimo <= ll[1]  //if Low smaller or equal to Lowest low
            ll := nimo  //Lowest low = low 
            ll
        else

            //else (Low is greater than Lowest low)
            if ximo > ll[1] + ll[1] * percent  //if high > Lowest low + Lowest low * Percent
                hh := ximo  //Highest high = high
                hhh := high

                trend := 1  //trend up
                trend


pt = trend > trend[1] ? 1 : trend < trend[1] ? -1 : 0  //Change in Trend
vor = trend == 1 ? hh : trend == -1 ? ll : na
vor1 = pt == 1 ? ll : pt == -1 ? hh : na


plot(vor, color=trend == 1 ? color.green : color.red, style=plot.style_circles, linewidth=2, title="zigi", transp=0, join=true)
plot(vor1, color=trend == 1 ? color.red : color.green, style=plot.style_line, linewidth=2, title="zigzag", transp=0, join=true, offset=-1)

//

long = trend == 1 and trend[1] == -1 
short = trend == -1 and trend[1] == 1 

last_long = 0.0
last_short = 0.0
last_long := long ? time : nz(last_long[1])
last_short := short ? time : nz(last_short[1])

long_signal = crossover(last_long, last_short)
short_signal = crossover(last_short, last_long)


/////////////// Plotting /////////////// 
plotshape(long_signal, style=shape.triangleup, size=size.normal, location=location.belowbar, color=color.lime)
plotshape(short_signal, style=shape.triangledown, size=size.normal, location=location.abovebar, color=color.red)


/////////////// Alerts /////////////// 
alertcondition(long_signal, title='Long', message='Long Signal')
alertcondition(short_signal, title='Short', message='Short Signal')
