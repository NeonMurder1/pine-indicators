//@version=3
study("makemoney-hybrid", shorttitle="makemoney-hybrid", overlay=true)
// Super Trend Strategy

sLines = input(true, "Show Super-Trend Lines")
Factor1=input(1,type =float, minval=1,maxval = 100)
Factor2=input(2,type =float, minval=1,maxval = 100)
Factor3=input(3,type =float, minval=1,maxval = 100)
Pd1=10 //input(10,minval=1,maxval = 100)
Pd2=10 //input(10,minval=1,maxval = 100)
Pd3=10 //input(10,minval=1,maxval = 100)

// ST1

Up1=hlc3-(Factor1*atr(Pd1))
Up2=hlc3-(Factor2*atr(Pd2))
Up3=hlc3-(Factor3*atr(Pd3))
Dn1=hlc3+(Factor1*atr(Pd1))
Dn2=hlc3+(Factor2*atr(Pd2))
Dn3=hlc3+(Factor3*atr(Pd3))

// ST1.2

TrendUp1=na
TrendUp2=na
TrendUp3=na
TrendUp1:=close[1]>TrendUp1[1]? max(Up1,TrendUp1[1]) : Up1
TrendUp2:=close[1]>TrendUp2[1]? max(Up2,TrendUp2[1]) : Up2
TrendUp3:=close[1]>TrendUp3[1]? max(Up3,TrendUp3[1]) : Up3

TrendDown1=na
TrendDown2=na
TrendDown3=na
TrendDown1:=close[1]<TrendDown1[1]? min(Dn1,TrendDown1[1]) : Dn1
TrendDown2:=close[1]<TrendDown2[1]? min(Dn2,TrendDown2[1]) : Dn2
TrendDown3:=close[1]<TrendDown3[1]? min(Dn3,TrendDown3[1]) : Dn3
 
Trend1 = na
Tsl1 = na
Trend2 = na
Tsl2 = na
Trend3 = na
Tsl3 = na
Trend1 := close[1] > TrendDown1[1] ? 1: close[1] < TrendUp1[1]? -1: nz(Trend1[1],1)
Tsl1 := Trend1==1 ? TrendUp1: TrendDown1
Trend2 := close[1] > TrendDown2[1] ? 1: close[1] < TrendUp2[1]? -1: nz(Trend2[1],1)
Tsl2 := Trend2==1 ? TrendUp2: TrendDown2
Trend3 := close[1] > TrendDown3[1] ? 1: close[1] < TrendUp3[1]? -1: nz(Trend3[1],1)
Tsl3 := Trend3==1 ? TrendUp3: TrendDown3

// Plotting

linecolor = Tsl1 < Tsl2 and Tsl2 < Tsl3 ? red : Tsl1 > Tsl2 and Tsl2 > Tsl3 ? lime : orange
plot(sLines ? Tsl2 : na, color = linecolor , style = line , linewidth = 2 ,title = "SuperTrend")


// Conditions

longCond1 = na
shortCond1 = na
longCond1 := crossover(close, Tsl3)  
shortCond1 :=crossunder(close, Tsl3) 

//
length = input(title="Bollinger Length", type=integer, defval=20, minval=1)
multiplier = input(title="Bollinger Deviation", type=float, defval=2, minval=1)
overbought = input(title="Overbought", type=integer, defval=1, minval=1)
oversold = input(title="Oversold", type=integer, defval=0, minval=1)
custom_timeframe = input(title="Use another Timeframe?", type=bool, defval=false)
highTimeFrame = input(title="Select The Timeframe", type=resolution, defval="60")
res1 = custom_timeframe ? highTimeFrame : period

smabasis = sma(close, length)
stdev = stdev(close, length)
cierre = security(tickerid, res1, close, false)
alta = security(tickerid, res1, high, false)
baja = security(tickerid, res1, low, false)
basis1 = security(tickerid, res1, smabasis, false)
stdevb = security(tickerid, res1, stdev, false)
dev = multiplier * stdevb // stdev(cierre, length)
upper = basis1 + dev
lower = basis1 - dev

bbr = (cierre - lower)/(upper - lower)

// plot(bbr)

// // MARCA LAS RESISTENCIAS
pintarojo = 0.0
pintarojo := nz(pintarojo[1])
pintarojo := bbr[1] > overbought and bbr < overbought ? alta[1] :  nz(pintarojo[1])
p = plot(pintarojo, color = red, style=circles, linewidth=2)

// // MARCA LOS SOPORTES
pintaverde = 0.0
pintaverde := nz(pintaverde[1])
pintaverde := bbr[1] < oversold and bbr > oversold ? baja[1] :  nz(pintaverde[1])
g = plot(pintaverde, color = black, style=circles, linewidth=2)
//
method = input(defval="ATR", options=["ATR", "Traditional", "Part of Price"], title="Renko Assignment Method")
methodvalue = input(defval=14.0, type=float, minval=0, title="Value")
pricesource = input(defval="Close", options=["Close", "Open / Close", "High / Low"], title="Price Source")
useClose = pricesource == "Close"
useOpenClose = pricesource == "Open / Close" or useClose
useTrueRange = input(defval="Auto", options=["Always", "Auto", "Never"], title="Use True Range instead of Volume")
isOscillating=input(defval=true, type=bool, title="Oscillating")
normalize=input(defval=false, type=bool, title="Normalize")
vol = useTrueRange == "Always" or (useTrueRange == "Auto" and na(volume))? tr : volume
op = useClose ? close : open
hi = useOpenClose ? close >= op ? close : op : high
lo = useOpenClose ? close <= op ? close : op : low

if method == "ATR"
    methodvalue := atr(round(methodvalue))
if method == "Part of Price"
    methodvalue := close/methodvalue

currclose = na
prevclose = nz(currclose[1])
prevhigh = prevclose + methodvalue
prevlow = prevclose - methodvalue
currclose := hi > prevhigh ? hi : lo < prevlow ? lo : prevclose

direction = na
direction := currclose > prevclose ? 1 : currclose < prevclose ? -1 : nz(direction[1])
directionHasChanged = change(direction) != 0
directionIsUp = direction > 0
directionIsDown = direction < 0

barcount = 1
barcount := not directionHasChanged and normalize ? barcount[1] + barcount : barcount
vol := not directionHasChanged ? vol[1] + vol : vol
res = barcount > 1 ? vol/barcount : vol


x=isOscillating and directionIsDown ? -res : res


// Conditions

longCond = na
shortCond = na
longCond :=  crossover(close, Tsl3)  
shortCond :=  crossunder(x,0) 

// Count your long short conditions for more control with Pyramiding

sectionLongs = 0
sectionLongs := nz(sectionLongs[1])
sectionShorts = 0
sectionShorts := nz(sectionShorts[1])

if longCond
    sectionLongs := sectionLongs + 1
    sectionShorts := 0

if shortCond
    sectionLongs := 0
    sectionShorts := sectionShorts + 1
    
// Pyramiding

pyrl = 1

// These check to see your signal and cross references it against the pyramiding settings above

longCondition = longCond and sectionLongs <= pyrl 
shortCondition = shortCond and sectionShorts <= pyrl 

// Get the price of the last opened long or short

last_open_longCondition = na
last_open_shortCondition = na
last_open_longCondition := longCondition ? open : nz(last_open_longCondition[1])
last_open_shortCondition := shortCondition ? open : nz(last_open_shortCondition[1])

// Check if your last postion was a long or a short

last_longCondition = na
last_shortCondition = na
last_longCondition := longCondition ? time : nz(last_longCondition[1])
last_shortCondition := shortCondition ? time : nz(last_shortCondition[1])

in_longCondition = last_longCondition > last_shortCondition
in_shortCondition = last_shortCondition > last_longCondition

// Take profit

isTPl = input(false, "Take Profit Long")
isTPs = input(false, "Take Profit Short")
tp = input(2, "Take Profit %", type=float)
long_tp = isTPl and crossover(high, (1+(tp/100))*last_open_longCondition) and longCondition == 0 and in_longCondition  == 1 
short_tp = isTPs and crossunder(low, (1-(tp/100))*last_open_shortCondition) and shortCondition == 0 and in_shortCondition == 1 

// Stop Loss

isSLl = input(false, "Stop Loss Long")
isSLs = input(false, "Stop Loss Short")
sl= 0.0
sl := input(3, "Stop Loss %", type=float)
long_sl = isSLl and crossunder(low, (1-(sl/100))*last_open_longCondition) and longCondition == 0 and in_longCondition == 1
short_sl = isSLs and crossover(high, (1+(sl/100))*last_open_shortCondition) and shortCondition == 0 and in_shortCondition == 1

// Create a single close for all the different closing conditions.

long_close = long_tp or long_sl ? 1 : 0
short_close = short_tp or short_sl ? 1 : 0

// Get the time of the last close

last_long_close = na
last_short_close = na
last_long_close := long_close ? time : nz(last_long_close[1])
last_short_close := short_close ? time : nz(last_short_close[1])


// Alerts & Signals
bgcolor(color = longCond1 ? aqua : shortCond1 ? fuchsia : na, transp = 60)
plotshape(longCond1, title = "Buy Signal", text = "B", style=shape.triangleup, location=location.belowbar, color = black, editable = false, transp = 0)
plotshape(shortCond, title = "Sell Signal", text = "S", style=shape.triangledown, location=location.abovebar, color = black, editable = false, transp = 0)

bton(b) => b ? 1 : 0

plotshape(long_tp and last_longCondition > nz(last_long_close[1]), text ="TP", title="Take Profit Long", style=shape.triangledown, 
   location=location.abovebar, color = red, editable = false, transp = 0) 
plotshape(short_tp and last_shortCondition > nz(last_short_close[1]) , text ="TP", title="Take Profit Short", style=shape.triangleup, 
   location=location.belowbar, color = lime, editable = false, transp = 0) 

ltp = iff(long_tp and last_longCondition > nz(last_long_close[1]), (1+(tp/100))*last_open_longCondition, na)
plot(ltp, style=cross, linewidth=3, color = white, editable = false)
stp = iff(short_tp and last_shortCondition > nz(last_short_close[1]), (1-(tp/100))*last_open_shortCondition, na)
plot(stp, style = cross, linewidth=3, color = white, editable = false)

plotshape(long_sl and last_longCondition > nz(last_long_close[1]), text ="SL", title="Stop Loss Long", style=shape.triangledown, 
   location=location.abovebar, color = red, editable = false, transp = 0) 
plotshape(short_sl and last_shortCondition > nz(last_short_close[1]), text ="SL", title="Stop Loss Short", style=shape.triangleup, 
   location=location.belowbar, color = lime, editable = false, transp = 0) 

lsl = iff(long_sl and last_longCondition > nz(last_long_close[1]), (1-(sl/100))*last_open_longCondition, na)
plot(lsl, style=cross, linewidth=3, color = white, editable = false)
ssl = iff(short_sl and last_shortCondition > nz(last_short_close[1]), (1+(sl/100))*last_open_shortCondition, na)
plot(ssl, style = cross, linewidth=3, color = white, editable = false)
//
showZones   = input(true, title="Show Bullish/Bearish Zones")
// bullish signal rule: 
bullishRule = close >= Tsl3
// bearish signal rule: 
bearishRule = close <= Tsl3
// current trading State
ruleState = 0
ruleState := bullishRule ? 1 : bearishRule ? -1 : nz(ruleState[1])
bgcolor(showZones ? ( ruleState==1 ? green : ruleState==-1 ? red : gray ) : na , title="supertrend Bullish/Bearish Zones", transp=90)

//

alertcondition(bton(longCondition), title="Buy Alert")
alertcondition(bton(shortCondition), title="Sell Alert")
alertcondition(bton(long_tp and last_longCondition > nz(last_long_close[1])), title="Take Profit Long")
alertcondition(bton(short_tp and last_shortCondition > nz(last_short_close[1])), title="Take Profit Short")
alertcondition(bton(long_sl and last_longCondition > nz(last_long_close[1])), title="Stop Loss Long")
alertcondition(bton(short_sl and last_shortCondition > nz(last_short_close[1])), title="Stop Loss Short")
