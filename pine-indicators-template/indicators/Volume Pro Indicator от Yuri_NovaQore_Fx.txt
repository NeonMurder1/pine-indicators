// © Yuri Speri - Modificato con VAH e VAL ottimizzati

//@version=6
indicator("Volume Pro Indicator", overlay=true, max_bars_back=5000, max_lines_count=500)

var is_first_candle = true
var diff = 0.0
var maxV = 0.0
var maxV_index = 0
var last_time = 0
var bar_offset = 0
var is_first_inRange = false

// Parametri per periodi lunghi
period_time = input.int(50, "Number of days", minval=3, maxval=500)
resolution = input.int(500, "calculation resolution", minval=400, maxval=700)

// Parametri per VAH/VAL
value_area_percent = input.float(70, "Value Area % (standard 70%)", minval=50, maxval=90, step=1)

// Opzioni di visualizzazione
show_volume_bars = input.bool(true, "Show volume bars (If selected, maximum days are 17)")
show_vpoc_line = input.bool(true, "Show VPOC line")
show_vah_line = input.bool(true, "Show VAH line", inline="vah_val")
show_val_line = input.bool(true, "Show VAL line", inline="vah_val")

// Colori
vpoc_color = input.color(color.new(color.white, 10), "VPOC color")
vah_val_color = input.color(color.new(color.aqua, 50), "VAH/VAL lines color")
mode = input.string("Buy/Sell", "Volume Mode", options=["Buy/Sell", "Delta"])
color_buy = input.color(color.new(color.green, 20), "Buy/Positive delta volume color")
color_sell = input.color(color.new(color.red, 20), "Sell/Negative delta volume color")
color_neutral = input.color(color.new(color.gray, 20), "Neutral volume color")

// Arrays
var range_prices = array.new_float((resolution + 1), 0.0)
var partial_vol = array.new_float(resolution, 0.0)
var total_vol = array.new_float(resolution, 0.0)
var buy_vol = array.new_float(resolution, 0.0)
var sell_vol = array.new_float(resolution, 0.0)

t = time("1440", "regular")
var int startTime = time
var ncandles = 0

if barstate.isfirst
    startTime := timenow - period_time*86400000

bar_offset := ta.barssince(is_first_inRange)
is_first = na(t[1]) and not na(t) or t[1] < t
is_first_inRange := is_first and t > startTime
high_price = 0.0
low_price = 0.0

// Variabili per VAH e VAL
var float vah_price = 0.0
var float val_price = 0.0

if is_first_inRange or barstate.islast
    last_time := t[1]
    ncandles := bar_offset
    
    // Calcola high/low
    current_low_price = 0.0
    for i = 1 to ncandles
        current_low_price := low[i]
        if current_low_price < low_price or low_price == 0.0
            low_price := current_low_price
            
    current_high_price = 0.0
    for i = 1 to ncandles
        current_high_price := high[i]
        if current_high_price > high_price or high_price == 0.0
            high_price := current_high_price
    
    diff := (high_price - low_price) / resolution
    
    for j = 0 to resolution
        array.set(range_prices, j, (low_price + (diff * (j+1))))
    
    array.fill(total_vol, 0.0)
    array.fill(buy_vol, 0.0)
    array.fill(sell_vol, 0.0)
    
    // Analisi del volume
    for i = 0 to ncandles
        w_candle = 0
        array.fill(partial_vol, 0.0)
        
        // Determina se la candela è bullish (buy) o bearish (sell)
        is_bullish = close[i] > open[i]
        current_volume = nz(volume[i])
        
        for j = 0 to resolution - 1
            current_price = array.get(range_prices, j)
            if high[i] > current_price and low[i] < current_price
                j_partial_vol = array.get(partial_vol, j)
                sum_vol = j_partial_vol + current_volume
                array.set(partial_vol, j, sum_vol)
                
                // Aggiorna i volumi buy/sell in base al tipo di candela
                if is_bullish
                    array.set(buy_vol, j, array.get(buy_vol, j) + current_volume)
                else
                    array.set(sell_vol, j, array.get(sell_vol, j) + current_volume)
                
                w_candle += 1
        
        for j = 0 to resolution - 1
            j_total_vol = array.get(total_vol, j)
            j_partial_vol = array.get(partial_vol, j)
            sum_partial_total = 0.0
            if w_candle > 0
                sum_partial_total := j_total_vol + j_partial_vol / w_candle
            else 
                sum_partial_total := j_total_vol
            array.set(total_vol, j, sum_partial_total)
    
    // Trova il punto di massimo volume (VPOC)
    maxV := array.max(total_vol)
    maxV_index := array.indexof(total_vol, maxV)
    
    // Calcolo VAH/VAL usando il metodo standard del Value Area Volume (70%)
    // 1. Inizia dal POC
    // 2. Aggiungi volumi fino a raggiungere la percentuale target del volume totale
    
    // Calcola il volume totale
    float total_volume_sum = 0.0
    for i = 0 to resolution - 1
        total_volume_sum := total_volume_sum + array.get(total_vol, i)
    
    // Calcola il target volume per Value Area (standard 70%)
    float target_volume = total_volume_sum * (value_area_percent / 100)
    
    // Inizializza con il POC
    float current_volume_sum = array.get(total_vol, maxV_index)
    
    // Indici per tracciare i limiti attuali della Value Area
    int upper_index = maxV_index
    int lower_index = maxV_index
    
    // Espandi simmetricamente dal POC finché non si raggiunge la percentuale target
    while current_volume_sum < target_volume and (upper_index < resolution - 1 or lower_index > 0)
        float upper_vol = upper_index < resolution - 1 ? array.get(total_vol, upper_index + 1) : 0
        float lower_vol = lower_index > 0 ? array.get(total_vol, lower_index - 1) : 0
        
        // Aggiungi il maggiore dei due volumi adiacenti
        if upper_vol >= lower_vol and upper_index < resolution - 1
            upper_index := upper_index + 1
            current_volume_sum := current_volume_sum + upper_vol
        else if lower_index > 0
            lower_index := lower_index - 1
            current_volume_sum := current_volume_sum + lower_vol
    
    // Imposta VAH e VAL in base agli indici trovati
    vah_price := array.get(range_prices, upper_index)
    val_price := array.get(range_prices, lower_index)

dif_time = 0.0

if is_first_inRange or barstate.islast
    last_time := int(t[1])
    dif_time := (time - last_time)
    
    if dif_time / 86400000 > 1.5
        dif_time := dif_time / 9
    else
        dif_time := dif_time / 3
        
    var diff_t = 0
    var x1 = 0.0
    proportion = resolution / 40
    
    // Disegna barre di volume
    for i = 0 to resolution - 1
        y = array.get(range_prices, i)
        current_vol = array.get(total_vol, i)
        var norm_vol = 0.0
        norm_vol := current_vol / maxV
        x1 := dif_time * norm_vol
        diff_t := last_time + int(x1)
        
        // Determina il colore in base alla modalità selezionata
        volume_color = color_neutral
        
        buy_volume = array.get(buy_vol, i)
        sell_volume = array.get(sell_vol, i)
        total_volume = buy_volume + sell_volume
        
        if mode == "Buy/Sell"
            if total_volume > 0
                buy_ratio = buy_volume / total_volume
                
                if buy_ratio > 0.6
                    volume_color := color_buy
                else if buy_ratio < 0.4
                    volume_color := color_sell
        else
            delta = buy_volume - sell_volume
            if delta > 0
                intensity = math.min(delta / (total_volume * 0.5), 1.0)
                volume_color := color.new(color.green, 60 - math.round(intensity * 40))
            else if delta < 0
                intensity = math.min(math.abs(delta) / (total_volume * 0.5), 1.0)
                volume_color := color.new(color.red, 60 - math.round(intensity * 40))
        
        if (i % int(proportion) == 0 or int(proportion) == 0) and show_volume_bars
            if norm_vol > 0.0
                line.new(x1=t[1], y1=y, x2=diff_t, y2=y, color=volume_color, xloc=xloc.bar_time, extend=extend.none, width=3)
    
    // Disegna linee VAL, VPOC e VAH
    if show_val_line
        line.new(x1=t[1], y1=val_price, x2=time, y2=val_price, xloc=xloc.bar_time, color=vah_val_color)
        
    if show_vpoc_line
        line.new(x1=t[1], y1=diff*maxV_index+low_price, x2=time, y2=diff*maxV_index+low_price, color=vpoc_color, width=2, xloc=xloc.bar_time)
        
    if show_vah_line 
        line.new(x1=t[1], y1=vah_price, x2=time, y2=vah_price, xloc=xloc.bar_time, color=vah_val_color)