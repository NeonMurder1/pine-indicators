// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © PrometheusAnalytics

//@version=5
indicator("Prometheus Markov Chain", overlay = true)

dimension = input.int(4, title = "Input Matrix dimensions, will be NxN", tooltip = "The transition matrix is what we set to get probabilities for states", group = "Transition Matrix")
use_custom_thresh = input.bool(false, title = "Would you like to use a custom Percent Return Threshold?", tooltip = "How big a candle's percent return would need to be for the model to take it into account for state", group = "Prediction")
custom_thresh = input.float(1.0, title = "Percent Return Threshold", group = "Prediction")

size = math.pow(dimension, 2)
vec = array.new<int>(int(size), 0)

stateFunc(value, max_value, min_value) =>
    
    if value < value[3] and value < min_value[1] //value < value[1] and value < value[2] and value < value[3] and value < min_value[1]
        0
    else if value > value[3] and value > max_value[1] //value > value[1] and value > value[2] and value > value[3] and value > max_value[1]
        2
    else
        1

stateFunc(value, thresh) =>
    pct_thrsh = thresh / 100
    if value < value[1] and value < value[2] and value < value[3] and value < -pct_thrsh
        0
    else if value > value[1] and value > value[2] and value > value[3] and value > pct_thrsh
        2
    else
        1

for i = 1 to size-1
    chng = (close[i] - close[i-1]) / close[i-1]

    if not use_custom_thresh
        highest_chng = ta.highest(chng, int(size) * 2)
        lowest_chng = ta.lowest(chng, int(size) * 2)
        state = stateFunc(chng, highest_chng, lowest_chng)
        array.set(vec, i, state)
    else
        state = stateFunc(chng, custom_thresh)
        array.set(vec, i, state)

transitionMatrix = matrix.new<float>(dimension, dimension, 0.0)
for i = 0 to array.size(vec) - 2
    fromState = array.get(vec, i)
    toState = array.get(vec, i + 1)
    transitionMatrix.set(fromState, toState, transitionMatrix.get(fromState, toState) + 1)

for i = 0 to dimension - 1
    rowSum = 0.0
    for j = 0 to dimension - 1
        rowSum += transitionMatrix.get(i, j)
    for j = 0 to dimension - 1
        prob = transitionMatrix.get(i, j) / rowSum
        transitionMatrix.set(i, j, prob)

current_chng = (close - close[1]) / close[1]
var int current_state = na
if not use_custom_thresh
    highest_chng = ta.highest(current_chng, int(size) * 2)
    lowest_chng = ta.lowest(current_chng, int(size) * 2)
    current_state := stateFunc(current_chng, highest_chng, lowest_chng)
else
    current_state := stateFunc(current_chng, custom_thresh)

predicted_probs = array.new<float>(dimension, 0.0)
for j = 0 to dimension - 1
    array.set(predicted_probs, j, transitionMatrix.get(current_state, j))

next_state = 0
highest_prob = array.get(predicted_probs, 0)
for j = 1 to dimension - 1
    prob = array.get(predicted_probs, j)
    if prob > highest_prob
        highest_prob := prob
        next_state := j

if next_state != next_state[1] and barstate.isconfirmed and session.ismarket
    if next_state == 2
        label.new(bar_index, low, "Predicted Next State: Bullish", yloc = yloc.belowbar, color=color.green, textcolor=color.black, style = label.style_label_up, size = size.small)

    if next_state == 0
        label.new(bar_index, high, "Predicted Next State: Bearish", yloc = yloc.abovebar, color=color.red, textcolor=color.black, style = label.style_label_down, size = size.small)